// server.js - Complete Healthcare AI Platform Server
import express from 'express';
import cors from 'cors';
import multer from 'multer';
import helmet from 'helmet';
import compression from 'compression';
import dotenv from 'dotenv';
import path from 'path';
import fs from 'fs/promises';
import { fileURLToPath } from 'url';
import { GeminiService, DocumentAIService, ComplianceEngine } from './src/services/index.js';

// ES modules compatibility
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Load environment variables
dotenv.config();

// Initialize Express app
const app = express();
const PORT = process.env.PORT || 3000;

// Security middleware
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
}));

// Compression for better performance
app.use(compression());

// CORS configuration
app.use(cors({
  origin: process.env.NODE_ENV === 'production' 
    ? process.env.FRONTEND_URL 
    : ['http://localhost:3000', 'http://localhost:3001'],
  credentials: true
}));

// Body parser middleware
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// File upload configuration
const upload = multer({
  dest: 'uploads/',
  limits: { fileSize: 20 * 1024 * 1024 }, // 20MB limit
  fileFilter: (req, file, cb) => {
    const allowedTypes = [
      'application/pdf',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'text/plain',
      'application/msword'
    ];
    
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Invalid file type. Only PDF, DOC, DOCX, and TXT files are allowed.'));
    }
  }
});

// Initialize services
let geminiService, documentAIService, complianceEngine;
let servicesInitialized = false;

async function initializeServices() {
  try {
    console.log('ğŸ”§ Initializing Healthcare AI Services...');
    
    // Initialize Gemini AI
    geminiService = new GeminiService();
    const geminiReady = geminiService.initialize();
    
    // Initialize Document AI
    documentAIService = new DocumentAIService();
    const documentAIReady = await documentAIService.initialize();
    
    // Initialize Compliance Engine
    complianceEngine = new ComplianceEngine();
    
    servicesInitialized = geminiReady || documentAIReady;
    
    if (servicesInitialized) {
      console.log('âœ… Healthcare AI services initialized successfully');
    } else {
      console.warn('âš ï¸ Some services failed to initialize - running in limited mode');
    }
    
    return servicesInitialized;
  } catch (error) {
    console.error('âŒ Service initialization failed:', error);
    return false;
  }
}

// Health check endpoint
app.get('/health', (req, res) => {
  const services = {
    server: 'operational',
    gemini: geminiService?.model ? 'connected' : 'disconnected',
    documentAI: documentAIService?.client ? 'connected' : 'disconnected',
    compliance: 'operational',
    database: 'not_configured'
  };
  
  const allHealthy = Object.values(services).every(status => 
    status === 'operational' || status === 'connected'
  );
  
  res.status(allHealthy ? 200 : 503).json({
    status: allHealthy ? 'healthy' : 'degraded',
    timestamp: new Date().toISOString(),
    project: process.env.GOOGLE_CLOUD_PROJECT,
    services
  });
});

// Main workflow endpoint
app.post('/api/workflow/complete', upload.single('document'), async (req, res) => {
  try {
    const {
      methodology = 'agile',
      complianceFramework = 'HIPAA',
      testingDepth = 'comprehensive'
    } = req.body;
    
    console.log(`ğŸš€ Processing workflow: ${methodology}/${complianceFramework}`);
    
    let extractedData = null;
    let requirements = [];
    
    // Process uploaded document
    if (req.file) {
      console.log(`ğŸ“„ Processing file: ${req.file.originalname}`);
      
      // Use Document AI if available
      if (documentAIService?.client) {
        try {
          const docResult = await documentAIService.processHealthcareDocument(
            req.file.path,
            req.file.mimetype
          );
          
          // Extract requirements from Document AI results
          requirements = docResult.entities.map((entity, idx) => ({
            id: `REQ${String(idx + 1).padStart(3, '0')}`,
            text: entity.text,
            category: entity.type,
            confidence: entity.confidence
          }));
          
          extractedData = {
            filename: req.file.originalname,
            requirements,
            documentType: path.extname(req.file.originalname),
            processedAt: new Date().toISOString(),
            processingMethod: 'Google Document AI',
            formFields: docResult.formFields,
            entities: docResult.entities,
            confidence: docResult.confidence
          };
        } catch (error) {
          console.error('Document AI processing failed:', error);
          // Fallback to basic text extraction
          const fileContent = await fs.readFile(req.file.path, 'utf-8');
          requirements = extractBasicRequirements(fileContent);
          extractedData = createBasicExtractedData(req.file, requirements);
        }
      } else {
        // Basic text extraction fallback
        const fileContent = await fs.readFile(req.file.path, 'utf-8');
        requirements = extractBasicRequirements(fileContent);
        extractedData = createBasicExtractedData(req.file, requirements);
      }
      
      // Clean up uploaded file
      await fs.unlink(req.file.path);
    } else {
      // Use default healthcare requirements
      requirements = getDefaultHealthcareRequirements();
      extractedData = createDefaultExtractedData(requirements);
    }
    
    console.log(`ğŸ“‹ Found ${requirements.length} requirements`);
    
    // Generate test cases using Gemini AI
    let testCases = null;
    
    if (geminiService?.model && requirements.length > 0) {
      try {
        testCases = await geminiService.generateTestCases(
          requirements,
          methodology,
          complianceFramework
        );
        console.log(`ğŸ§ª Generated ${testCases.testCases?.length || 0} test cases`);
      } catch (error) {
        console.error('AI test generation failed:', error);
        testCases = generateMockTestCases(requirements, methodology, complianceFramework);
      }
    } else {
      testCases = generateMockTestCases(requirements, methodology, complianceFramework);
    }
    
    // Apply compliance rules
    if (complianceEngine && testCases) {
      testCases = complianceEngine.applyComplianceRules(testCases, complianceFramework);
      
      // Validate coverage
      const coverage = complianceEngine.validateTestCoverage(
        testCases.testCases,
        requirements
      );
      
      testCases.coverage = coverage;
    }
    
    // Send successful response
    res.json({
      success: true,
      methodology,
      complianceFramework,
      extractedData,
      testCases,
      processedAt: new Date().toISOString(),
      serviceStatus: {
        documentAI: !!documentAIService?.client,
        geminiAI: !!geminiService?.model,
        complianceEngine: true
      }
    });
    
  } catch (error) {
    console.error('âŒ Workflow error:', error);
    
    // Clean up file on error
    if (req.file?.path) {
      await fs.unlink(req.file.path).catch(console.error);
    }
    
    res.status(500).json({
      success: false,
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});

// Export endpoint for test results
app.post('/api/export', async (req, res) => {
  try {
    const { testCases, format = 'json', includeCompliance = true } = req.body;
    
    if (!testCases || !testCases.length) {
      return res.status(400).json({
        success: false,
        error: 'No test cases to export'
      });
    }
    
    let exportData;
    let contentType;
    let filename;
    
    switch (format.toLowerCase()) {
      case 'csv':
        exportData = convertToCSV(testCases, includeCompliance);
        contentType = 'text/csv';
        filename = `test-cases-${Date.now()}.csv`;
        break;
        
      case 'jira':
        exportData = convertToJiraFormat(testCases);
        contentType = 'application/json';
        filename = `jira-import-${Date.now()}.json`;
        break;
        
      case 'excel':
        exportData = await convertToExcel(testCases, includeCompliance);
        contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
        filename = `test-cases-${Date.now()}.xlsx`;
        break;
        
      default:
        exportData = JSON.stringify({ testCases }, null, 2);
        contentType = 'application/json';
        filename = `test-cases-${Date.now()}.json`;
    }
    
    res.setHeader('Content-Type', contentType);
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.send(exportData);
    
  } catch (error) {
    console.error('Export error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Utility functions
function extractBasicRequirements(text) {
  const lines = text.split('\n').filter(line => line.trim());
  return lines.slice(0, 20).map((line, idx) => ({
    id: `REQ${String(idx + 1).padStart(3, '0')}`,
    text: line.trim(),
    category: categorizeRequirement(line),
    priority: 'medium'
  }));
}

function categorizeRequirement(text) {
  const lower = text.toLowerCase();
  if (lower.includes('security') || lower.includes('encrypt')) return 'security';
  if (lower.includes('hipaa') || lower.includes('compliance')) return 'compliance';
  if (lower.includes('performance') || lower.includes('speed')) return 'performance';
  if (lower.includes('user') || lower.includes('interface')) return 'usability';
  return 'functional';
}

function createBasicExtractedData(file, requirements) {
  return {
    filename: file.originalname,
    requirements,
    documentType: path.extname(file.originalname),
    processedAt: new Date().toISOString(),
    processingMethod: 'Basic Text Extraction',
    formFields: [],
    entities: []
  };
}

function createDefaultExtractedData(requirements) {
  return {
    filename: 'default-healthcare-requirements.txt',
    requirements,
    documentType: '.txt',
    processedAt: new Date().toISOString(),
    processingMethod: 'Default Dataset',
    formFields: [],
    entities: []
  };
}

function getDefaultHealthcareRequirements() {
  return [
    {
      id: 'REQ001',
      text: 'System must implement multi-factor authentication for all users accessing PHI',
      category: 'security',
      priority: 'critical'
    },
    {
      id: 'REQ002',
      text: 'All PHI data must be encrypted at rest using AES-256 encryption',
      category: 'security',
      priority: 'critical'
    },
    {
      id: 'REQ003',
      text: 'System must maintain comprehensive audit logs for all PHI access',
      category: 'compliance',
      priority: 'high'
    },
    {
      id: 'REQ004',
      text: 'Patient consent must be obtained and validated before data processing',
      category: 'compliance',
      priority: 'critical'
    },
    {
      id: 'REQ005',
      text: 'System must support role-based access control with minimum necessary access',
      category: 'security',
      priority: 'high'
    }
  ];
}

function generateMockTestCases(requirements, methodology, compliance) {
  const testCases = requirements.map((req, idx) => ({
    testId: `TC${String(idx + 1).padStart(3, '0')}`,
    testName: `Test for ${req.text.substring(0, 50)}...`,
    description: `Verify that ${req.text}`,
    priority: req.priority === 'critical' ? 'High' : 'Medium',
    category: req.category,
    testingTechnique: 'functional-validation',
    riskLevel: req.priority === 'critical' ? 'High' : 'Medium',
    complianceRequirements: [compliance],
    automationPotential: 'Medium',
    preconditions: ['System is operational', 'Test data is available'],
    testSteps: ['Step 1: Prepare test environment', 'Step 2: Execute test', 'Step 3: Verify results'],
    expectedResults: ['Requirement is satisfied'],
    requirementId: req.id
  }));
  
  return {
    testCases,
    summary: {
      totalTestCases: testCases.length,
      coverage: 85,
      highPriorityCount: testCases.filter(tc => tc.priority === 'High').length,
      complianceFramework: compliance,
      methodology
    }
  };
}

function convertToCSV(testCases, includeCompliance) {
  const headers = [
    'Test ID', 'Test Name', 'Description', 'Priority', 
    'Category', 'Risk Level', 'Requirement ID'
  ];
  
  if (includeCompliance) {
    headers.push('Compliance Requirements');
  }
  
  const rows = testCases.map(tc => {
    const row = [
      tc.testId,
      tc.testName,
      tc.description,
      tc.priority,
      tc.category,
      tc.riskLevel,
      tc.requirementId
    ];
    
    if (includeCompliance) {
      row.push(tc.complianceRequirements.join('; '));
    }
    
    return row.join(',');
  });
  
  return [headers.join(','), ...rows].join('\n');
}

function convertToJiraFormat(testCases) {
  return {
    projects: [{
      key: 'MEDTEST',
      issues: testCases.map(tc => ({
        fields: {
          project: { key: 'MEDTEST' },
          summary: tc.testName,
          description: tc.description,
          issuetype: { name: 'Test' },
          priority: { name: tc.priority },
          labels: [tc.category, tc.complianceRequirements[0]],
          customfield_10001: tc.testSteps.join('\n'),
          customfield_10002: tc.expectedResults.join('\n')
        }
      }))
    }]
  };
}

async function convertToExcel(testCases, includeCompliance) {
  // This would use a library like xlsx or exceljs
  // For now, returning CSV as fallback
  return convertToCSV(testCases, includeCompliance);
}

// Static file serving for production
if (process.env.NODE_ENV === 'production') {
  app.use(express.static(path.join(__dirname, 'frontend/build')));
  
  app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, 'frontend/build', 'index.html'));
  });
}

// Error handling middleware
app.use((err, req, res, next) => {
  console.error('Global error handler:', err);
  
  res.status(err.status || 500).json({
    success: false,
    error: err.message || 'Internal server error',
    stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
  });
});

// Start server
async function startServer() {
  try {
    // Initialize services before starting
    await initializeServices();
    
    app.listen(PORT, () => {
      console.log('ğŸ¥ MedTestAI Healthcare Platform Server');
      console.log('=====================================');
      console.log(`ğŸ“ Server running on port ${PORT}`);
      console.log(`ğŸŒ Health check: http://localhost:${PORT}/health`);
      console.log(`ğŸ” Environment: ${process.env.NODE_ENV || 'development'}`);
      console.log(`â˜ï¸  GCP Project: ${process.env.GOOGLE_CLOUD_PROJECT || 'Not configured'}`);
      console.log('=====================================');
    });
  } catch (error) {
    console.error('Failed to start server:', error);
    process.exit(1);
  }
}

// Start the application
startServer();