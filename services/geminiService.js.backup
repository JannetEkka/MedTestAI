// services/geminiService.js - FIXED VERSION
import { GoogleGenerativeAI } from '@google/generative-ai';

class GeminiService {
  constructor() {
    this.genAI = process.env.GEMINI_API_KEY 
      ? new GoogleGenerativeAI(process.env.GEMINI_API_KEY)
      : null;
    this.model = null;
  }

  initialize() {
    if (!this.genAI) {
      console.warn('⚠️ Gemini API key not configured');
      return false;
    }
    
    this.model = this.genAI.getGenerativeModel({ 
      model: "gemini-2.5-flash",
      generationConfig: {
        temperature: 0.7,
        topK: 40,
        topP: 0.95,
        maxOutputTokens: 8192,
        responseMimeType: "application/json"  // CRITICAL FIX: Force JSON response
      }
    });
    
    console.log('✅ Gemini AI service initialized');
    return true;
  }

  // FIXED: Robust JSON cleaning and parsing
  cleanJsonResponse(text) {
    let cleaned = text.replace(/```json\n?/g, '').replace(/```\n?/g, '');
    cleaned = cleaned.replace(/<!DOCTYPE[^>]*>/gi, '');
    cleaned = cleaned.replace(/<\/?html[^>]*>/gi, '');
    cleaned = cleaned.replace(/<\/?head[^>]*>/gi, '');
    cleaned = cleaned.replace(/<\/?body[^>]*>/gi, '');
    cleaned = cleaned.trim();
    
    const jsonStart = cleaned.indexOf('{');
    const jsonEnd = cleaned.lastIndexOf('}') + 1;
    
    if (jsonStart !== -1 && jsonEnd > jsonStart) {
      cleaned = cleaned.substring(jsonStart, jsonEnd);
    }
    
    return cleaned;
  }

  async generateTestCases(requirements, methodology = 'agile', compliance = 'HIPAA') {
    if (!this.model) {
      throw new Error('Gemini model not initialized');
    }

    const prompt = `Generate comprehensive healthcare software test cases.

Requirements: ${JSON.stringify(requirements)}
Methodology: ${methodology}
Compliance Framework: ${compliance}

CRITICAL: Return ONLY valid JSON, no markdown, no HTML.

{
  "testCases": [
    {
      "testId": "TC001",
      "testName": "string",
      "description": "string",
      "priority": "High|Medium|Low",
      "category": "functional|security|performance|usability",
      "testingTechnique": "boundary-value|equivalence-partitioning|decision-table",
      "riskLevel": "High|Medium|Low",
      "complianceRequirements": [],
      "automationPotential": "High|Medium|Low",
      "preconditions": [],
      "testSteps": [],
      "expectedResults": [],
      "actualResults": "",
      "status": "Not Started",
      "requirementId": "string"
    }
  ],
  "summary": {
    "totalTestCases": 0,
    "coverage": 0,
    "highPriorityCount": 0,
    "complianceFramework": "${compliance}",
    "categoriesCount": {"functional": 0, "security": 0, "performance": 0, "usability": 0}
  }
}`;

    try {
      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      let text = response.text();
      
      text = this.cleanJsonResponse(text);
      const testData = JSON.parse(text);
      
      if (!testData.testCases || !Array.isArray(testData.testCases)) {
        throw new Error('Invalid response structure: missing testCases array');
      }
      
      testData.generatedAt = new Date().toISOString();
      testData.methodology = methodology;
      testData.aiModel = 'gemini-2.5-flash';
      
      return testData;
    } catch (error) {
      console.error('❌ Test generation error:', error);
      if (error instanceof SyntaxError) {
        throw new Error(`JSON parsing failed: ${error.message}`);
      }
      throw new Error(`Failed to generate test cases: ${error.message}`);
    }
  }

  async analyzeRequirements(text) {
    if (!this.model) {
      throw new Error('Gemini model not initialized');
    }

    const prompt = `Analyze this healthcare requirement document.

Document: ${text}

Return ONLY valid JSON:
{
  "requirements": [{"id": "REQ001", "text": "...", "category": "functional", "priority": "high", "testable": true, "acceptanceCriteria": [], "dependencies": [], "complianceMapping": []}],
  "documentSummary": {"totalRequirements": 0, "categories": {"functional": 0, "nonFunctional": 0, "security": 0, "compliance": 0}, "testabilityScore": 0, "complianceFrameworks": []}
}`;

    try {
      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      let text = response.text();
      text = this.cleanJsonResponse(text);
      return JSON.parse(text);
    } catch (error) {
      console.error('❌ Requirements analysis error:', error);
      throw new Error(`Failed to analyze requirements: ${error.message}`);
    }
  }
}

export default new GeminiService();